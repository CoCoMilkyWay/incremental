[%%org {|
#+TITLE: Incremental tutorial, Part 7: Performance and Optimization

The whole point of using Incremental is to optimize your program.
This section is meant to provide a guide to understanding and
improving the performance of your incremental program.

As is always the case, the most important part of optimization is
measuring, so whatever else you do, building yourself some benchmarks
so you can tell when your code is doing better or worse is an
important starting point.

But it's also good to have a reasonable mental cost model for the
programming you're doing, and generating such a model for Incremental
is a little tricky, so we'll talk about that as well.

* The cost model

*Incremental nodes are expensive.* The most important part of that is
their sheer size. One incremental node being a record of 27 fields,
meaning that the record alone is 216 bytes, without even counting the
things pointed to by an incremental node.

Firing an incremental node isn't free either. It takes somewhere
between 50ns-150ns to fire a single incremental node.  That's not
huge, but it's a lot more than some of the computations you might put
inside of an incremental node.  This should be a reminder not to
over-incrementalize; a very fine-grained incrementalization can be
both harder to use and slower than a coarse grained one.

*Stabilization, on the other hand, are nearly free.*  A single
stabilization where there's nothing to be done takes under 100ns.  So
in most applications, you don't have to worry about the cost of
stabilizing too often.  (There are, however, some computational
benefits of batching updates together beyond saving the time of an
empty stabilization.  We'll discuss those later.)

Another thing worth thinking about when it comes to Incremental is
which parts of the graph are actually going to be fired.  There are
two key rules that are worth keeping in mind.

- *Only dependents of nodes which have changed can ever be fired.*  By
  default, a node counts as having changed if its new value is
  physically different from its previous value.  This can be changed
  by modifying the cutoff function for a give node.

- *Only nodes that are /necessary/ will fire.* A node is necessary if
  there's some observer that transitively depends on that node.
  Merely holding on to a copy of some incremental node is not enough
  to make it run; it also has to be connected to an observer.

This means that Incremental provides a kind of best-of-both-worlds
between demand-driven and change-driven change propagation, in that
only the intersection of what is changed and what is necessary will be
recomputed.

This does not amount to a complete cost model, but hopefully it
provides a solid starting point for thinking about the cost of an
incremental computation.

With this cost model in hand, let's explore some techniques for
improving the performance of incremental computations.

* Measuring incremental

Incremental has some built in tools for gathering statistics about
incremental computations.  You'll find these functions in the ~State~
module.  For example, the following code shows you how to read out the
number of Incremental nodes that have been created.
|}]

open Core
module Incr = Incremental.Make ()
module Incr_map = Incr_map.Make(Incr);;
open Incr.Let_syntax

     #verbose true;;
let _ = Incr.State.num_nodes_created Incr.State.t;;
[%%expect{|
- : int = 0
|}]
let i = Incr.Var.create 0 |> Incr.Var.watch |> Incr.map ~f:succ;;
[%%expect {|
val i : int Incr.t = <abstr>
|}];;
let _ = Incr.State.num_nodes_created Incr.State.t;;
[%%expect {|
- : int = 2
|}];;

[%%org {|
Let's create a little module for capturing and reporting some of the
stats from ~Incr.State~.
|}]

module Stats : sig
  val reporter : unit -> (unit -> unit) Staged.t
end = struct
  type t =
    { created : int
    ; recomputed : int
    ; changed : int
    }
  [@@deriving sexp]

  let diff t1 t2 =
    { created = t1.created - t2.created
    ; recomputed = t1.recomputed - t2.recomputed
    ; changed = t1.changed - t2.changed
    }
  ;;

  let snap () =
    { created = Incr.State.num_nodes_created Incr.State.t
    ; recomputed = Incr.State.num_nodes_recomputed Incr.State.t
    ; changed = Incr.State.num_nodes_changed Incr.State.t
    }
  ;;

  let reporter () =
    let open Expect_test_helpers_kernel in
    let old_stats = ref (snap ()) in
    let report () =
      let stats = snap () in
      print_s [%sexp (diff stats !old_stats : t)];
      old_stats := stats
    in
    stage report
  ;;
end
[%%expect {|
module Stats : sig val reporter : unit -> (unit -> unit) Staged.t end
|}];;

[%%org {|
We can create a stats reporter now and use it for printing out the
number of created, changed and recomputed nodes.
|}]

let report = unstage (Stats.reporter ());;
[%%expect {|
val report : unit -> unit = <fun>
|}];;

let () = report ()
[%%expect {|
((created    0)
 (recomputed 0)
 (changed    0))
|}];;

[%%org {|
Now, let's create a small incremental computation that takes a map
full of integers and sums the squares together.  From the outside, it
looks like this should create only three computation nodes.
|}]

let (input,sum_sq) =
  let input =
    let m = Map.of_alist_exn (module Int) (List.init 1_000 ~f:(fun x -> (x,x))) in
    Incr.Var.create m
  in
  let squares = Incr_map.mapi (Incr.Var.watch input) ~f:(fun ~key:_ ~data:x -> x * x) in
  let sum_sq =
    let change op ~key:_ ~data acc = op acc data in
    Incr_map.unordered_fold squares ~init:0 ~add:(change (+)) ~remove:(change (-))
  in
  (input, Incr.observe sum_sq)

[%%expect{|
val input : (int, int, Int.comparator_witness) Map.t Incr.Var.t = <abstr>
val sum_sq : int Incr.Observer.t = <abstr>
|}]

[%%org {|
Now, let's run the reporter and see what actually happened.
|}]

let () = report ()
[%%expect {|
((created    3)
 (recomputed 0)
 (changed    0))
|}];;

[%%org {|
If we now modify the input, we should see all three nodes change.
|}]

let () =
  Incr.Var.set input (Map.remove (Incr.Var.value input) 100);
  Incr.stabilize ();
  report ();
[%%expect{|
((created    0)
 (recomputed 3)
 (changed    3))
|}]

[%%org {|
If, on the other hand, we use ~incr_map'~ to do the same computation,
we'll see very different numbers.
|}]

let (input,sum_sq) =
  let input =
    let m = Map.of_alist_exn (module Int) (List.init 1_000 ~f:(fun x -> (x,x))) in
    Incr.Var.create m
  in
  let squares = Incr_map.mapi' (Incr.Var.watch input) ~f:(fun ~key:_ ~data:x ->
    let%map x = x in x + 1)
  in
  let change op ~key:_ ~data acc = op acc data in
  let sum_sq =
    Incr_map.unordered_fold squares ~init:0 ~add:(change (+)) ~remove:(change (-))
    |> Incr.observe
  in
  (input,sum_sq)
[%%expect {|
val input : (int, int, Int.comparator_witness) Map.t Incr.Var.t = <abstr>
val sum_sq : int Incr.Observer.t = <abstr>
|}];;

let print () =
  Incr.stabilize ();
  print_s [%sexp (Incr.Observer.value_exn sum_sq : int)];
  report ()
[%%expect {|
val print : unit -> unit = <fun>
|}];;

let () = print ()
[%%expect{|
500500
((created    2008)
 (recomputed 2008)
 (changed    2008))
|}]

[%%org {|
Here we can see that we're creating a bunch more incremental
nodes. But, when we update just one node, we'll see a small number of changes.
|}]

let change f =
  Incr.Var.set input (f (Incr.Var.value input))

let () =
  change (fun m -> Map.set m ~key:100 ~data:101);
  print ()
[%%expect{|
val change :
  ((int, int, Int.comparator_witness) Map.t ->
   (int, int, Int.comparator_witness) Map.t) ->
  unit = <fun>
500501
((created    0)
 (recomputed 7)
 (changed    6))
|}]

[%%org {|
Note that if we add a new key that wasn't in the map, we'll see nodes
being created as well.
|}]

let () =
  change (fun m -> (Map.set m ~key:1001 ~data:1001));
  print ()
[%%expect {|
501503
((created    2)
 (recomputed 7)
 (changed    6))
|}];;

[%%org {|
Grabbing statistics like this from incremental is useful because it
helps you build up an intuition as to what your program is doing and
why.

Another useful tool that the [State] exposes is the ability to
generate a graph specification, suitable for display via
[[https://www.graphviz.org/doc/info/lang.html][dot]].
|}]

[%%org {|

* Batching changes

The fact that Incremental separates out updating the variables from
running stabilization opens up one simple form of optimization, i.e.,
batching.  By stabilizing less often, you can red

|}]

let () =
  change (fun m -> (Map.remove m 10));
  change (fun m -> (Map.remove m 30));
  change (fun m -> (Map.remove m 50));
  change (fun m -> (Map.remove m 100));
  print ()
[%%expect {|
501308
((created    0)
 (recomputed 5)
 (changed    4))
|}];;



[%%org {|

* Prefer ~mapi~ to ~mapi'~

* Filter first

* Share computations

* Minimize what's observed

|}]



[%%org {|
Removing a node, however, causes fewer nodes to recompute, since you
only have to recompute nodes at the end.
|}]

